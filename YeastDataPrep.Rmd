---
title: 'Yeast Data Preparation: Filtering, Aggregation, and Normalisation'
author: "M.Soria"
date: "`r Sys.Date()`"
output:
  html_document: null
  toc: yes
  pdf_document: default
theme: cosmo
---

### Introduction

The following code consists of the data preparation steps for the RNA-Seq data for Saccharomyces cerevisiae. 
The data preparation consists of quality filtering, aggregation, and normalisation.

### Prerequisite libraries

```{r Libraries, echo=TRUE}

suppressPackageStartupMessages({
    library(R.utils)
    library(dplyr)
    library(tidyr)
    library(data.table)
    library(RColorBrewer)
    library(gplots)
    library(edgeR)
    library(reshape2)
    library (igraph)
    library(networkD3)
    library(Polychrome)
})

source("functions.R")

```

### 1. Download and unzip the Yeast data 

```{r Download Data, echo=TRUE}

# if statement checks if object exists

if (!file.exists("Data/scerevisiae_se.tsv.bz2")){
    download.file("http://dee2.io/mx/scerevisiae_se.tsv.bz2", 
              destfile = "Data/scerevisiae_se.tsv.bz2")}

if (!file.exists("Data/scerevisiae_se.tsv")){
    bunzip2("Data/scerevisiae_se.tsv.bz2", destname="Data/scerevisiae_se.tsv")}

scerevisiae_data <- fread("Data/scerevisiae_se.tsv", sep = '\t', header = FALSE)

head(scerevisiae_data)

```

### 2. Download, read, and unzip the QC data

```{r QC Data, echo=TRUE}

if (!file.exists("Data/scerevisiae_qc.tsv.bz2")){
    download.file("http://dee2.io/mx/scerevisiae_qc.tsv.bz2", 
              destfile = "Data/scerevisiae_qc.tsv.bz2")}

quality_data <- fread("Data/scerevisiae_qc.tsv.bz2", sep = '\t', 
  col.names = c("Database", "Description", "Details"))

head(quality_data)

```

### 3. Filter and quantify databases according to QC_SUMMARY = PASS, WARN, or FAIL.  

```{r QC Data Summary, echo=TRUE}

# Count the total number of QC_SUMMARY entries for checking
qc_summary <- quality_data[quality_data$Description == 'QC_SUMMARY',]
total_summary <- nrow(qc_summary)

# Count the total number of databases marked as PASS
qc_pass <- filter(quality_data, grepl("PASS", Details))
total_pass <- nrow(qc_pass)

# Count the total number of databases marked as WARN
qc_warn <- filter(quality_data, grepl("WARN", Details))
total_warn <- nrow(qc_warn)

# Count the total number of databases marked as FAIL
qc_fail <- filter(quality_data, grepl("FAIL", Details))
total_fail <- nrow(qc_fail)

# Summary of counts. Addition of each PASS, WARN, and FAIL counts equals to total_summary.
quality_summary <- data.frame(total_pass, total_warn, total_fail, total_summary)
quality_summary

```

### 4. Select all the databses from scerevisiae_se.tsv with QC_SUMMARY == 'PASS' 

```{r Filter yeast bulk data, echo=TRUE}

# Filter all the sample names with QC_SUMMARY == 'PASS' from step 3
databse_pass <- filter(quality_data, grepl("PASS", Details)) 

# Convert the rows into string and store on a list to use for filtering Yeast data
databse_pass_list <- as.list(as.character(databse_pass$Database))

# Filter Yeast data using generated list
scerevisiae_pass <- scerevisiae_data[scerevisiae_data$V1 %in% databse_pass_list,] 

# Convert format from long to wide
scerevisiae_pass_wide <- scerevisiae_pass %>% pivot_wider(names_from = "V1", values_from = "V3")

# Convert tibble to data frame and assign column 1 as rowname
scerevisiae_pass_wide <- as.data.frame(scerevisiae_pass_wide)
rownames(scerevisiae_pass_wide) <- scerevisiae_pass_wide[,1]
scerevisiae_pass_wide <- scerevisiae_pass_wide[,-1]

scerevisiae_pass_wide[1:10,1:6]

```

### 5. Aggregate multiple runs, if any, (SRR) to its corresponding experiment (SRX) with PASS only databases

```{r SRR to SRX Aggregation, echo=TRUE}

# Download and read Metadata summary

if (!file.exists("Data/scerevisiae_metadata.tsv.cut")){
    download.file("http://dee2.io/metadata/scerevisiae_metadata.tsv.cut", 
              destfile = "Data/scerevisiae_metadata.tsv.cut")}
    
yeast_metadata <- read.csv("Data/scerevisiae_metadata.tsv.cut", sep = '\t')

# Filter metadata to include only "passed" samples
yeast_metadata_pass <- yeast_metadata[yeast_metadata$SRR_accession %in% databse_pass_list,]

# Assign column 1 as rownames 
rownames(yeast_metadata_pass) <- yeast_metadata_pass[,1]
yeast_metadata_pass <- yeast_metadata_pass[,-1]

# Put the filtered yeast GeneCount data and the filtered metadata dataframes into a list
yeast_count_metadata <- list(GeneCounts = scerevisiae_pass_wide, MetadataSummary = yeast_metadata_pass)

# Apply both dataframes to the function
agg <- srx_agg(yeast_count_metadata)

# Remove genes with zero total counts 
length(which(rowSums(agg) == 0)) # 83
no_gene_counts <- names(which(rowSums(agg) == 0))

agg <- agg[!(rownames(agg) %in% no_gene_counts),]

# Save agg object
saveRDS(agg, "agg.rds")

# Histogram showing samples (columns) counts
hist(colSums(agg), breaks = 30)

```

### 6. Normalisation of Data (with PASS only databases)

A CPM of 0.6 is used as it corresponds to a count of 10-15 for the library sizes in this data set. If the count is any smaller, it is considered to be very low, indicating that the associated gene is not expressed in that sample.As a general rule, a good threshold can be chosen by identifying the CPM that corresponds to a count of 10, which in this case is about 0.6.You should filter with CPMs rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples.

Note: When in doubt, a threshold of 1 CPM in at least minimum group sample size is a good rule of thumb.

```{r eval=FALSE, include=FALSE}

#NORMALISATION FOR COMPOSITION BIAS (TMM normalisation)
dgeObj <- DGEList(agg)
# Apply TMM normalisation to DGEList object
dgeObj <- calcNormFactors(dgeObj, method = "TMM") 
tmm_agg <- cpm(dgeObj, log=TRUE)
dim(tmm_agg)
# Check distributions of samples
hist(tmm_agg)
saveRDS(tmm_agg,"tmm_agg.rds")

#Z-SCORE SCALING
s_agg <- scale(agg)
dim(s_agg)
# Check distributions of samples
hist(s_agg)
saveRDS(s_agg,"s_agg.rds")

# Check ave correlation for each Normalisation method
pdf("Data/Scaling.pdf") 
#calculate the row mean  
avcor<-cor(rowMeans(s_agg),s_agg,method="pearson")
hist(avcor,main="Pearson correlation to dataset average: Scaled data")
mtext(paste("mean=",signif(mean(avcor),3)),cex=1.2)
avcor<-cor(rowMeans(s_agg),s_agg,method="spearman")
hist(avcor,main="Spearman correlation to dataset average: Scaled data")
mtext(paste("mean=",signif(mean(avcor),3)),cex=1.2)

avcor<-cor(rowMeans(tmm_agg),tmm_agg,method="pearson")
hist(avcor,main="Pearson correlation to dataset average: TMM Normalised data")
mtext(paste("mean=",signif(mean(avcor),3)),cex=1.2)
avcor<-cor(rowMeans(tmm_agg),tmm_agg,method="spearman")
hist(avcor,main="Spearman correlation to dataset average: TMM Normalised data")
mtext(paste("mean=",signif(mean(avcor),3)),cex=1.2)

dev.off()


# Multi-dimensional Scaling - Torgerson method:
# deals with numerical distances, in which there is no 
# measurement error (you have exactly one distance measure for 
# each pair of items)
mds_Sagg<-cmdscale(dist(t(s_agg)))
mds_TMMagg<-cmdscale(dist(t(tmm_agg)))

pdf("Data/MDS.pdf") 
#noabel
plot(tmm_agg, xlab="Coordinate 1", ylab="Coordinate 2", main="MDS by gene: TMM Normalised data", cex=0.6, pch=19)
#labeled
plot(tmm_agg, xlab="Coordinate 1", ylab="Coordinate 2", main="MDS by gene: TMM Normalised data", cex=0.6, pch=19)
text( tmm_agg , labels=rownames(tmm_agg) ,cex=0.8) 

#nolabel
plot(s_agg, xlab="Coordinate 1", ylab="Coordinate 2", main="MDS by gene: Scaled data", cex=0.6, pch=19) 
#label
plot(s_agg, xlab="Coordinate 1", ylab="Coordinate 2", main="MDS by gene: Scaled data", cex=0.6, pch=19)
text(s_agg , labels=rownames(s_agg) ,cex=0.8)

dev.off()

```

### 7. Heirarchical Clustering with PASS only databases

This chunk can be reused for the PASS + Warn or the WARN filters by changing the content of the filename object. Do not forget to change the name of the variable where you will save the clusters for different inputs. 

```{r echo=TRUE}

h_cluster <- function(counts,cutree_val,dist_met){
  h <- list()
  
  set.seed(42)
  c<-as.dist(1-cor(t(counts), method="spearman"))
  hr <- hclust(c , method="complete")
  mycl <- cutree(hr, h=max(hr$height/cutree_val))
  mycl_length <- length(unique(mycl))
  
  h[["hr"]] <- hr
  h[["mycl"]] <- mycl
  h[["mycl_length"]] <- mycl_length
  
  return(h)
}

#-----
# CLUSTERING

s_aggCL_sp <- h_cluster(s_agg, 1.78, dist_met="spearman")
  saveRDS(s_aggCL_sp,"s_aggCL_sp.rds")
tmm_aggCL_sp <- h_cluster(tmm_agg, 1.621, dist_met= "spearman")
  saveRDS(tmm_aggCL_sp,"tmm_aggCL_sp.rds")
tmm_aggCL_pr <- h_cluster(tmm_agg, 1.72, dist_met= "pearson")
  saveRDS(tmm_aggCL_pr,"tmm_aggCL_pr.rds")

# Prepare Cluster data frame
cl_data <- function(x1, x2) {
  for (i in x1){
    for (j in x2){
      clusters <- as.data.frame(x1[["mycl"]])
      colnames(clusters) <- "ClusterNumber"
      clusters$GeneID <- rownames(clusters)
      nCL <- paste0(j, ".rds")
      nh <- paste0("mycl_",j,".rds")
      saveRDS(clusters, as.character(nh))
    }
  }
}

x1 <- c(s_aggCL_sp, tmm_aggCL_sp, tmm_aggCL_pr)
x2 <- c("s_aggCL_sp", "tmm_aggCL_sp", "tmm_aggCL_pr")
cl_data(x1, x2)

```

### 8. Heatmaps for the clusters

```{r eval=FALSE, include=FALSE}
# Visualizations
if (!exists("P100")){
  P100 <- createPalette(100,  c("#ff0000", "#00ff00", "#0000ff"))}

clusterCols <- P100[1:100]
colfunc <- colorRampPalette(c("blue", "white", "red"))

# Heatmaps TMM

png("Data/hm_TMM_sp.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
myClusterSideBar <- clusterCols[tmm_aggCL_sp[["mycl"]]]
heatmap.2(cl_corr, main="Gene Correlation (TMM, Spearman)",  Rowv=as.dendrogram(hr),
          dendrogram="both", scale="col", col = colfunc(25), trace="none",
          RowSideColors= myClusterSideBar, margins = c(5,5))
dev.off()

png("Data/hm_TMM_pr.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
myClusterSideBar <- clusterCols[tmm_aggCL_pr[["mycl"]]]
heatmap.2(cl_corr, main="Gene Correlation (TMM, Pearson)",  Rowv=as.dendrogram(hr),
          dendrogram="both", scale="col", col = colfunc(25), trace="none",
          RowSideColors= myClusterSideBar, margins = c(5,5))
dev.off()

# Heatmaps Scaled
png("Data/hm_scaled_sp.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
myClusterSideBar <- clusterCols[s_aggCL_sp[["mycl"]]]
heatmap.2(cl_corr, main="Gene Correlation (Scaled)",  Rowv=as.dendrogram(hr),
          dendrogram="both", scale="col", col = colfunc(25), trace="none",
          RowSideColors= myClusterSideBar, margins = c(5,5))
dev.off()

```


### 9. Gene Ontology and Gene Data 

```{r}

# Get the GO Annotation File (GAF) format 2.1 of yeast
if (!file.exists("Data/scerevisiae_sgd.gaf.gz")){
    download.file("http://current.geneontology.org/annotations/sgd.gaf.gz", 
              destfile = "Data/scerevisiae_sgd.gaf.gz")}
if (!file.exists("Data/scerevisiae_sgd.gaf")){
    gunzip("Data/scerevisiae_sgd.gaf.gz", destname="Data/scerevisiae_sgd.gaf")}

scerevisiae_GO <- fread("Data/scerevisiae_sgd.gaf", sep = '\t', header = FALSE)

# Subset unique GeneIDs (V11) and GO IDs (V5) in a dataframe. 
# Select the first gene synonym from column V11 and delete the rest. 
# Use this as the GeneID column. 
# Add another column with 1 in each row indicating the relationship of the Gene ID to the GO ID

scerevisiae_GO_matrix <- data.frame(unique(scerevisiae_GO[,c(11,5)]))
scerevisiae_GO_matrix$GeneID <- gsub("\\|.*", "", scerevisiae_GO_matrix$V11)
scerevisiae_GO_matrix$V3 <- as.numeric(paste(1, scerevisiae_GO_matrix$V3))
scerevisiae_GO_matrix <- scerevisiae_GO_matrix[,-1]

# Convert the dataframe to wide format with Gene ID as column 1 and GO ID as column names 
scerevisiae_GO_matrix_wide <- scerevisiae_GO_matrix %>% pivot_wider(names_from = "V5", values_from = "V3")
scerevisiae_GO_matrix_wide <- as.data.frame(scerevisiae_GO_matrix_wide)
colnames(scerevisiae_GO_matrix_wide)[1] <- "GeneID"

# Convert NA to Zero
scerevisiae_GO_matrix_wide[is.na(scerevisiae_GO_matrix_wide)] <- 0

# Save the dataframe to an RDS file
saveRDS(scerevisiae_GO_matrix_wide, "scerevisiae_GO_matrix_wide.rds")

# GeneIDs that are in the gene count data but not in the GO matrix
diff_Count.GO <- setdiff(rownames(agg), scerevisiae_GO_matrix_wide$GeneID)

# GeneIDs that are in the GO matrix but not in the  gene count data
diff_GO.Count <- setdiff(scerevisiae_GO_matrix_wide$GeneID, rownames(agg))

# Remove the GeneIDs that are in the GO matrix but not in the gene count data
IndexRemoved <- which(scerevisiae_GO_matrix_wide$GeneID %in% diff_GO.Count)
GO_table <- scerevisiae_GO_matrix_wide
GO_table <- GO_table[-IndexRemoved,]
# Check if the genes were properly removed 
diff_GO.Count2 <- setdiff(GO_table$GeneID, rownames(agg))
dim(diff_GO.Count2)

# Save the new GO table
saveRDS(GO_table, "GO_table.rds")

```

### 10. Topographical Analysis

```{r eval=FALSE, include=FALSE}


# Create a graph adjacency based on correlation distances between genes in  pairwise fashion.
g <- graph.adjacency(
  as.matrix(as.dist(1-cor(t(s_agg), method="spearman"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
g <- simplify(g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(g)[which(E(g)$weight<0)]$color <- "darkblue"

# Colour positive correlation edges as red
E(g)[which(E(g)$weight>0)]$color <- "darkred"

# Convert edge weights to absolute values
E(g)$weight <- abs(E(g)$weight)

# Change arrow size
# For directed graphs only
#E(g)$arrow.size <- 1.0

# Remove edges below absolute Pearson correlation 0.8
g <- delete_edges(g, E(g)[which(E(g)$weight<0.8)])

# Remove any vertices remaining that have no edges
g <- delete.vertices(g, degree(g)==0)

# Assign names to the graph vertices (optional)
#V(g)$name <- V(g)$name

# Change shape of graph vertices
V(g)$shape <- "sphere"

# Change colour of graph vertices
V(g)$color <- "skyblue"

# Change colour of vertex frames
V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
#scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
#vSizes <- (scale01(apply(s_agg, 1, mean)) + 1.0) * 10

# Amplify or decrease the width of the edges
#edgeweights <- E(g)$weight * 2.0

# Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
mst <- mst(g, algorithm="prim")

# Plot the tree object
png("Data/igraph_scaled_agg.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
plot(
  g,
  layout=layout.fruchterman.reingold,
  edge.curved=TRUE,
  vertex.size=vSizes,
  vertex.label.dist=-0.5,
  vertex.label.color="black",
  asp=FALSE,
  vertex.label.cex=0.6,
  edge.width=edgeweights,
  edge.arrow.mode=0,
  main="Yeast Gene Correlation Network")
dev.off()


#------
# Topological Analysis for GO network

GO_net <- readRDS("GO_table.rds")
rownames(GO_net) <- GO_net$GeneID
GO_net <- GO_net[,-1]

GO2 <- GO_net[1:100, 1:50]

links2 <- GO2[rowSums(GO2)>0,]
nodes2 <- rownames(links2)
nodes2 <- colnames(links2)

net2 <- graph_from_incidence_matrix(links2)
net2 <- simplify(net2, remove.multiple=TRUE, remove.loops=TRUE)
net2.bp <- bipartite.projection(net2)


png("Data/igraph_GO.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
plot(net2.bp$proj1,layout = l, vertex.label.color="black", vertex.label.dist=2,
     vertex.size=7, vertex.label="")
dev.off()

set.seed(42) 
l <- layout.fruchterman.reingold(net2, niter=50)
l2 <- layout.lgl(net2)
l3 <- layout_with_graphopt(net2.bp$proj1, charge=0.00001)

l <- layout_nicely(net2, dim=2)

plot(net2.bp$proj1, layout = l2,
     vertex.label.dist=1,
     #edge.curved = TRUE,
     edge.arrow.size=0.5, 
     vertex.label.cex=0.5, 
     vertex.label.family="Helvetica",
     vertex.label.font=2,
     vertex.shape="circle", 
     vertex.size=2, 
     vertex.label.color="black", 
     edge.width=0.2,
     vertex.label="")


p <- simpleNetwork(links2, height="100px", width="100px")

p

# save the widget
# library(htmlwidgets)
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/networkInteractive1.html"))

```

### 10. Data preparation functions

```{r echo=TRUE}

# A nested list with of the genes grouped per cluster and their 
# corresponding correlation values. 
corr_allClusters <- corr_per_clust(logcounts, clusters, 100)

# Save the correlations per cluster
saveRDS(corr_allClusters, "corr_allClusters.rds")


# A list of data frames containing all GO terms associated with the genes belonging to a cluster.

GOterms_allClusters <- GO_per_cl(GO_table, clusters, 100)

# Save the GO terms grouped per cluster
saveRDS(GOterms_allClusters, "GOterms_allClusters.rds")

```


### Session Information 

```{r Session Info, echo=FALSE}

sessionInfo()

```
