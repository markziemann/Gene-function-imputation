---
title: "Yeast Clusters with Gene Ontology"
author: "MSoria"
date: "8/24/2020"
output: html_document
---

</br>

***

##### The following code associates annotations from Gene Ontology to different clusters from the yeast genome using data from DEE2  

***

</br>


### Prerequisite libraries
```{r Libraries, echo=TRUE}
suppressPackageStartupMessages({c(library(R.utils), library(dplyr), library(tidyr), library(data.table), library(RColorBrewer), library(gplots), library(Polychrome), library(tidyverse), library(edgeR), library(GO.db), library(gage), library(gProfileR), library(factoextra), library(NbClust), library(org.Sc.sgd.db),library(stringi))})

```
</br>

###  1. Download and unzip the Yeast data 
```{r Download Data, echo=TRUE}
# put in an if statement to check if object exists

if (!file.exists("Data/scerevisiae_se.tsv.bz2")){
    download.file("http://dee2.io/mx/scerevisiae_se.tsv.bz2", 
              destfile = "Data/scerevisiae_se.tsv.bz2")}

# fread error msg: This file is very unusual: it ends abruptly without a final newline, and also its size is a multiple of 4096 bytes. Please properly end the last row with a newline using for example 'echo >> file' to avoid this  time to copy. 

# needed to go back to bunzip2
if (!file.exists("Data/scerevisiae_se.tsv")){
    bunzip2("Data/scerevisiae_se.tsv.bz2", destname="Data/scerevisiae_se.tsv")}

scerevisiae_data <- fread("Data/scerevisiae_se.tsv", sep = '\t', header = FALSE)

head(scerevisiae_data)
```
</br>

### 2. Download, read, and unzip the QC data
```{r QC Data, echo=TRUE}
if (!file.exists("Data/scerevisiae_qc.tsv.bz2")){
    download.file("http://dee2.io/mx/scerevisiae_qc.tsv.bz2", 
              destfile = "Data/scerevisiae_qc.tsv.bz2")}

quality_data <- fread("Data/scerevisiae_qc.tsv.bz2", sep = '\t', col.names = c("Database", "Description", "Details"))

head(quality_data)
```
</br>

### 3. Filter and quantify databases according to QC_SUMMARY = PASS.  
```{r QC Data Summary, echo=TRUE}

# count the total number of QC_SUMMARY entries for checking
qc_summary <- quality_data[quality_data$Description == 'QC_SUMMARY',]
total_summary <- nrow(qc_summary)

# count the total number of databases marked as PASS
qc_pass <- filter(quality_data, grepl("PASS", Details))
total_pass <- nrow(qc_pass)

```
</br>

### 4. Select all the databses from scerevisiae_se.tsv with QC_SUMMARY == 'PASS' 
```{r Filter yeast bulk data, echo=TRUE}

# filter all the sample names with QC_SUMMARY == 'PASS' from step 3
databse_pass <- filter(quality_data, grepl("PASS", Details)) 

# convert the rows into string and store on a list to use for filtering Yeast data
databse_pass_list <- as.list(as.character(databse_pass$Database))

# Filter Yeast data using generated list
scerevisiae_pass <- scerevisiae_data[scerevisiae_data$V1 %in% databse_pass_list,] 

# Convert format from long to wide
scerevisiae_pass_wide <- scerevisiae_pass %>% pivot_wider(names_from = "V1", values_from = "V3")

# Convert tibble to data frame and assign column 1 as rowname
scerevisiae_pass_wide <- as.data.frame(scerevisiae_pass_wide)
rownames(scerevisiae_pass_wide) <- scerevisiae_pass_wide[,1]
scerevisiae_pass_wide <- scerevisiae_pass_wide[,-1]

scerevisiae_pass_wide[1:10,1:6]

```
</br>

### 5. Aggregate the SRR run data to SRX experiment 
```{r SRR to SRX Aggregation, echo=TRUE}

# Download and read Metadata summary

if (!file.exists("Data/scerevisiae_metadata.tsv.cut")){
    download.file("http://dee2.io/metadata/scerevisiae_metadata.tsv.cut", 
              destfile = "Data/scerevisiae_metadata.tsv.cut")}
    
yeast_metadata <- read.csv("Data/scerevisiae_metadata.tsv.cut", sep = '\t')

# Filter metadata to include only "passed" samples
yeast_metadata_pass <- yeast_metadata[yeast_metadata$SRR_accession %in% databse_pass_list,]

# Assign column 1 as rownames 
rownames(yeast_metadata_pass) <- yeast_metadata_pass[,1]
yeast_metadata_pass <- yeast_metadata_pass[,-1]

# Sequencing Run aggregate function
srx_agg <- function(x,counts="GeneCounts") {
    IDX=which(names(x) %in% "GeneCounts")
    mds<-x$MetadataSummary
    n=nrow(x[[IDX]])
    SRX_dat <- vapply(X=unique(mds$SRX_accession) ,function(srx) {
        srrs<-rownames(mds)[which(mds$SRX_accession %in% srx)]
        if (length(srrs)>1) {
            rowSums(x[[IDX]][,srrs])
        } else {
            x[[IDX]][,srrs]
        }
    } , numeric(n))
    rownames(SRX_dat) <- rownames(x[[IDX]])
    colnames(SRX_dat) <- unique(mds$SRX_accession)
    SRX_dat
}

# Put the filtered yeast GeneCount data and the filtered metadata dataframes into a list
yeast_count_metadata <- list(GeneCounts = scerevisiae_pass_wide, MetadataSummary = yeast_metadata_pass)

# Apply both dataframes to the function
agg <- srx_agg(yeast_count_metadata)

agg[1:10,1:6]

# Check for samples with zero total counts
colSums(agg) == 0

# Histogram showing samples (columns) counts
hist(colSums(agg), breaks = 30)

# Filtering samples with more than 1 million reads
agg_f_col <- agg[, which(colSums(agg) >= 1e6)]

# Filtering genes with more than zero counts 
agg_f_row <- agg[which(rowSums(agg) > 0), ]

# No difference between the filtered and unfiltered columns  
dim(agg_f_col)
dim(agg)

# Rows ommited for genes with more than zero counts
dim(agg_f_row)


```
</br>

### 6. Normalisation of Data 

```{r eval=FALSE, include=FALSE}
# NORMALISATION FOR LIBRARY SIZE BIAS (cpm)
myCPM <- cpm(agg)
# add a small number to the entire dataframe to account for zero reads
myCPM <- myCPM + 0.01
# Filtering to remove lowly expressed genes
thresh <- myCPM > 0.6
# check if there are zero values. Result should be FALSE.
all(apply(apply(myCPM, 2, function(x) x==0), 2, any))

# Keep genes that have at least 2 TRUEs in each row of thresh
keep <- rowSums(thresh) >= 2

# Subset the rows of data to keep the more highly expressed genes
counts_keep <- myCPM[keep,]
summary(keep)
dim(counts_keep)

# A CPM of 0.6 is used as it corresponds to a count of 10-15 for the library sizes in this data set. If the count is any smaller, it is considered to be very low, indicating that the associated gene is not expressed in that sample. As a general rule, a good threshold can be chosen by identifying the CPM that corresponds to a count of 10, which in this case is about 0.6. You should filter with CPMs rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples.

# Note: When in doubt, a threshold of 1 CPM in at least minimum group sample size is a good rule of thumb.

# Check whether our threshold of 0.6 does indeed correspond to a count of about 10-15
# Add a vertical line at 0.6 CPM, and a horizontal line at Counts = 10
plot(myCPM[,1], agg[,1], ylim=c(0,50), xlim=c(0,3), abline(v=0.6, h=10, col="blue"), ylab = "Counts", xlab = "CPM", main = "Counts-per-million (CPM) vs Counts")

# Convert counts to DGEList object (from edgeR library)
dgeObj <- DGEList(counts_keep)

#NORMALISATION FOR COMPOSITION BIAS (TMM normalisation)
# Apply normalisation to DGEList object
dgeObj <- calcNormFactors(dgeObj) 
# dgeObj$samples

# Get log2 counts per million
logcounts <- cpm(dgeObj,log=TRUE)

# Check distributions of samples
hist(logcounts)
hist(counts_keep)

all(apply(apply(logcounts, 2, function(x) x==0), 2, any))
# Comment: should we remove the huge spike of less than 5 values?

```
</br>


### 8. Heirarchical Clustering with PASS only databases
```{r echo=TRUE}

# Applying Hierarchical Clustering after normalization
cl <-as.dist(1-cor(t(logcounts), method="spearman"))
hr <- hclust(cl , method="complete")

# optimizing the cluster size
mycl <- cutree(hr, h=max(hr$height/1.64))
head(mycl)

if (!exists("P100")){
  P100 <- createPalette(100,  c("#ff0000", "#00ff00", "#0000ff"))}
mycl_length <- length(unique(mycl))

clusterCols <- P100[1:mycl_length]
myClusterSideBar <- clusterCols[mycl]
colfunc <- colorRampPalette(c("blue", "white", "red"))
if (!file.exists("Data/scerevisiae_se.tsv")){
  write.table(mycl,file="Data/scerevisiae_pass.txt",quote=F,sep="\t")}

# create a 5 x 5 inch png image
png("Data/yeast_heatmaps_PASS_normalization3.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)          

# create the heatmap
heatmap.2(logcounts, main="S.cerevisiae PASS Samples",  Rowv=as.dendrogram(hr),
          dendrogram="both", scale="column", col = colfunc(25), trace="none", 
          RowSideColors= myClusterSideBar, margins = c(5,5))

dev.off()
```
</br>



### 9. Gene Ontology and Gene Matrix 
```{r}
# Get the GO Annotation File (GAF) format 2.1 of yeast
if (!file.exists("Data/scerevisiae_sgd.gaf.gz")){
    download.file("http://current.geneontology.org/annotations/sgd.gaf.gz", 
              destfile = "Data/scerevisiae_sgd.gaf.gz")}
if (!file.exists("Data/scerevisiae_sgd.gaf")){
    gunzip("Data/scerevisiae_sgd.gaf.gz", destname="Data/scerevisiae_sgd.gaf")}

scerevisiae_GO <- fread("Data/scerevisiae_sgd.gaf", sep = '\t', header = FALSE)
head(scerevisiae_GO)

# Subset unique GeneIDs (V11) and GO IDs (V5) in a dataframe. Select the first gene synonym from column V11 and delete the rest. Use this as the GeneID column. Add another column with 1 in each row indicating the relationship of the Gene ID to the GO ID

scerevisiae_GO_matrix <- data.frame(unique(scerevisiae_GO[,c(11,5)]))
scerevisiae_GO_matrix$GeneID <- gsub("\\|.*", " ", scerevisiae_GO_matrix$V11)
scerevisiae_GO_matrix$V3 <- as.numeric(paste(1, scerevisiae_GO_matrix$V3))
scerevisiae_GO_matrix <- scerevisiae_GO_matrix[,-1]

# Convert the dataframe to wide format with Gene ID as column 1 and GO ID as column names 
scerevisiae_GO_matrix_wide <- scerevisiae_GO_matrix %>% pivot_wider(names_from = "V5", values_from = "V3")
scerevisiae_GO_matrix_wide <- as.data.frame(scerevisiae_GO_matrix_wide)
colnames(scerevisiae_GO_matrix_wide)[1] <- "GeneID"


# convert NA to Zero
scerevisiae_GO_matrix_wide[is.na(scerevisiae_GO_matrix_wide)] <- 0
head(scerevisiae_GO_matrix_wide)

sample_heatmap<-heatmap(as.matrix(scerevisiae_GO_matrix_wide[1:100,2:100]))

```
</br>

### 10. Blinding genes using random strings

```{r}
#Fraction of the total number of genes to be blinded
frac_blind <- 0.10
number_of_genes <- round(nrow(agg)*frac_blind)

blind <- sample(rownames(agg), number_of_genes)

rand <- stri_rand_strings(number_of_genes, 15, pattern = "[A-Za-z]")
rand <- paste("blind_", rand, sep = "")
dict_blind <- data.frame(blind, rand)

agg_rand <- agg

ind_blind <- which(rownames(agg_rand) %in% blind)

rownames(agg_rand)[ind_blind] <- rand

```

</br>

### 11. Cluster Analysis
```{r}
# Prepare Cluster data frame
clusters <- as.data.frame(mycl)
colnames(clusters) <- "ClusterNumber"

# make a new column, GeneID, from rownames
clusters$GeneID <- rownames(clusters)

# remove rownames
rownames(clusters) <- c()


# Grouping genes by cluster 
cluster1 <- clusters[clusters$ClusterNumber == 1,] 
cluster1_list <- as.list(cluster1$GeneID)


# look for cluster gene match in GO dictionary and subset nonzero columns 
cluster1_GO <- scerevisiae_GO_matrix_wide[scerevisiae_GO_matrix_wide$GeneID %in% cluster1_list,] 
cluster1_GO_nonzero <- cluster1_GO[, !apply(cluster1_GO == 0, 2, all)]
cluster1_GO_nonzero


# cl (object in wich the herarchical clustering data was saved)
# cl_mat <- as.matrix(cl)
#cluster_1 <- cl_mat[rownames(cl_mat) %in% cluster1_list,]
# Comment: this was used initially as data input for the cluster_1 object but I replaced it with the normalised count data (logcounts)


# Correlation in Cluster 1
cluster_1 <- logcounts[rownames(logcounts) %in% cluster1_list,]
corr_cluster1 <- cor(t(cluster_1))
hist(corr_cluster1)
hist(logcounts)


#---function (correlation per cluster) where:
# x = logcounts (normalized gene counts from RNA seq)
# y = clusters (matrix of genes w/ cluster number)
# clust_total = total number of clusters

corr_per_clust <- function(x, y, clust_total){
  corr_cl <- list()
  for (i in 1:clust_total){
    clusterX <- y[y$ClusterNumber == i,]
    cluster_list <- as.list(clusterX$GeneID)
    cluster <- x[rownames(x) %in% cluster_list,]
    corr_result <- cor(t(cluster))
    corr_cl[[paste0("Cluster", i)]] <- corr_result
  }
  return(corr_cl)
}

corr_allClusters <- corr_per_clust(logcounts, clusters, 100)


# GO terms per cluster
cluster1_GO_terms <- scerevisiae_GO_matrix_wide[scerevisiae_GO_matrix_wide$GeneID %in% genesOfInterest,]
rownames(cluster1_GO_terms)<- cluster1_GO_terms[,1] 
cluster1_GO_terms[,1] = NULL

cluster1_GO_terms <- cluster1_GO_terms[,which(colSums(cluster1_GO_terms) > 0)]


#---function (GO terms per cluster)
# x = scerevisiae_GO_matrix_wide (matrix of genes belonging to a GO term)
# y = clusters (matrix of genes w/ cluster number)
# clust_total = total number of clusters

GO_per_cl <- function(x,y,clust_total){
  GO_cl <- list()
  for (i in 1:clust_total){
    clusterX <- y[y$ClusterNumber == i,]
    cluster_list <- as.list(clusterX$GeneID)
    cluster_GOterms <- x[x$GeneID %in% cluster_list,]
    rownames(cluster_GOterms)<- cluster_GOterms[,1] 
    cluster_GOterms[,1] <- c()
    cluster_GOterms <- cluster_GOterms[,which(colSums(cluster_GOterms) > 0)]
    GO_cl[[paste0("Cluster", i)]] <- cluster_GOterms
  }
  return(GO_cl)
}

GOterms_allClusters <- GO_per_cl(scerevisiae_GO_matrix_wide, clusters, 100)

 
# weighted correlation for Cluster 1
# ---note: how to apply this in all blind genes in a cluster
# ---result: a list of vector per gene in the cluster containing the GO terms

genesOfInterest <- rownames(cluster_1)
is_blind <- genesOfInterest[genesOfInterest %in% dict_blind$blind]
blind_gene <- is_blind[1]
corr_value_blind1 <- corr_cluster1[blind_gene,]
corr_value_blind1_df <- as.data.frame(corr_value_blind1)
weighted_go_cluster1 <- merge(corr_value_blind1_df, cluster1_GO_terms)
weighted_go_cluster1 <- weighted_go_cluster1[,1]*weighted_go_cluster1[,2:ncol(weighted_go_cluster1)]

normalized_weighted_go_cluster1 <- colSums(weighted_go_cluster1)/nrow(weighted_go_cluster1) 
hist(normalized_weighted_go_cluster1)


#---function (weighted correlation per gene in a cluster) where:
# gene_list = list of genes to be correlated; corr_cl = correlation values for cluster
# cl_GO = GO terms for cluster

wcorr_cluster <- function(gene_list, corr_cl, cl_GO){
  wcorr_result <- list()
  
  for (i in gene_list){
    corr_value <- corr_cl[i,]
    corr_value_df <- as.data.frame(corr_value)
    weighted_go <- merge(corr_value_df, cl_GO)
    weighted_go <- weighted_go[,1]*weighted_go[,2:ncol(weighted_go)]
    normalized_weighted_go <- colSums(weighted_go)/nrow(weighted_go)
    wcorr_result[[i]] <- normalized_weighted_go
  }
  setNames(wcorr_result, paste0(i))
  return(wcorr_result)
}

cluster1_wGO <- wcorr_cluster(is_blind, corr_cluster1, cluster1_GO_terms)



# Determining threshold based on histogram
hist(cluster1_wGO$YDL024C)
imputed_GO_terms <- names(which(normalized_weighted_go_cluster1 > 0.1))

# Convert output into a data frame with columns as GO terms and rows as gene names
cluster1_wGO_df <- as.data.frame(do.call(rbind, cluster1_wGO))

# using 0.1 as threshold
Clust1_threshold <- 0.1
imputed_Clust1_df <- as.data.frame(sapply(cluster1_wGO_df, function(x){
   as.numeric(x > Clust1_threshold)
  }))
row.names(imputed_Clust1_df) <- row.names(cluster1_wGO_df)



# Subtract input matrix (GO terms for imputed genes from original GO dataframe) from imputed df
# Comment: matrices have to be the same dimensions for direct comparison so filtering has to be done

# Filter all genes in cluster 1 from the original GO matrix
cluster1_inputMat <- scerevisiae_GO_matrix_wide[scerevisiae_GO_matrix_wide$GeneID %in% rownames(imputed_Clust1_df),]
rownames(cluster1_inputMat) <- cluster1_inputMat[,1]
cluster1_inputMat[,1] = c()

# Order by rownames and only include columns in the imputed df
cluster1_inputMat <- cluster1_inputMat[order(rownames(cluster1_inputMat)),]
cluster1_inputMat <- cluster1_inputMat[, colnames(cluster1_inputMat) %in% colnames(imputed_Clust1_df)]

# Comment: the dimensions of the resultant df (imputed df) has to be "trimmed down" as well according to the dimensions of the filtered df
cluster1_filtered_imputed <- imputed_Clust1_df[rownames(imputed_Clust1_df) %in% rownames(cluster1_inputMat),]
# rownames are ordered the same way as the cluster1_inputMat object for direct comparison
cluster1_filtered_imputed <- cluster1_[order(rownames(cluster1_)),]


# Comparison between input df and resultant df
# True or False similarity table
Clust1_inutVSimputed <- ifelse(cluster1_inputMat==cluster1_filtered_imputed, TRUE, FALSE)
# 1 or 0 table: 1 (similar) and 0 (dissimilar)
Clust1_mult <- cluster1_inputMat*cluster1_filtered_imputed

```
</br>

### 12. Gene Enrichment Analysis 
```{r echo=TRUE}
# ---------Functional Enrichment Analysis using using goProfileR

# Gene enrichment query
goResults_1 <- gprofiler(query = genesOfInterest,
                     organism = 'scerevisiae',
                     hier_filtering = 'none')

## Subset and reorder gProfiler results to only include columns of interest
gprofiler_results_oe_reordered <- goResults_1[, c("term.id", "domain", "term.name", "p.value", "overlap.size", "term.size", "intersection")]

# Order the results by p-adjusted value
gprofiler_results_oe_reordered <- gprofiler_results_oe_reordered[order(gprofiler_results_oe_reordered$p.value), ]
 
# Extract only the 'GO' terms from the results
gprofiler_results_oe_GOs <- gprofiler_results_oe_reordered[grep('GO:', gprofiler_results_oe_reordered$term.id), ]

# Write the enriched GO results to file
write.csv(gprofiler_results_oe_GOs,
            "Data/gprofiler_cluster1.csv")


# --------Over-representation analysis of biological processes
# perform Gene Set Enrichment Analysis (GSEA) using gage package

columns(org.Sc.sgd.db)
keys(org.Sc.sgd.db)
keytypes(org.Sc.sgd.db)

# The input to gage must be Entrez identifiers so we first need to map our gene symbols to Entrez
ann <- mapIds(org.Sc.sgd.db, keys=rownames(cluster_1), column="ENTREZID", keytype="ENSEMBL")
cluster1_non_na <- names(!is.na(ann))
fc <- logcounts[rownames(logcounts) %in% cluster1_non_na,]

table(is.na(fc))

# Create a mapping between gene identifiers and GO terms.
allGo <- as.list(GOTERM)
bp <- Filter(function(go) go@Ontology == 'BP', allGo)
goMapping <- mget(names(bp), org.Sc.sgdGO2ALLORFS, ifnotfound=NA)

# gene set enrichment analysis
goFc <- gage(fc, goMapping)
goGreater <- as.data.frame(goFc$greater)
goGreater <- goGreater[goGreater$q.val < 0.01 & !is.na(goGreater$q.val),]
goTermNames <- lapply(mget(rownames(goGreater), GOTERM), function(go) go@Term)
goGreater$Term <- goTermNames[rownames(goGreater)]
goGreater



#---------using clusterprofiler
library("clusterProfiler")


background_genes <- clusters[clusters$ClusterNumber !=1,]
background_geneIDs <- rownames(agg)

yeast_CP_go <- enrichGO(genesOfInterest, "org.Sc.sgd.db", keyType = "ENSEMBL", ont = "ALL", universe = background_geneIDs)
yeast_CP_go_df <- as.data.frame(yeast_CP_go)
yeast_CP_go_df
```

</br>


### 13. Assessing clustering tendency

```{r}

# Hopkins statistic: If the value of Hopkins statistic is close to 1 (far above 0.5), 
# then we can conclude that the dataset is significantly clusterable

# Visual approach: The visual approach detects the clustering tendency by counting 
# the number of square shaped dark (or colored) blocks along the diagonal in 
# the ordered dissimilarity image.

gradient.color <- list(low = "steelblue",  high = "white")

# create a 5 x 5 inch png image
png("Data/clustering_tendency_PASS.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)          
logcounts %>% get_clust_tendency(n = nrow(logcounts)-1, gradient = gradient.color)

dev.off()
```
</br>

### 14. K-means Clustering

```{r echo=TRUE}
# determining the number of clusters (K) using NbClust package

#val_K_clust <- NbClust(logcounts, min.nc=1, max.nc=100, method="kmeans")
num_K_clust <- fviz_nbclust(logcounts, FUNcluster = kmeans, method = "wss", print.summary = TRUE)

# K-means Clustering

# As k-means clustering algorithm starts with k randomly selected centroids, it’s always recommended to use the set.seed() function in order to set a seed for R’s random number generator

set.seed(123)
km.res_100 <- kmeans(logcounts, 100, nstart = 25, iter.max = 50)

png("Data/K_means_PASS.png", width = 5*300, height = 5*300, res = 300, pointsize = 8)
fviz_cluster(km.res, data = logcounts, geom="point")
dev.off()
```
</br>

### 15. Applying Function for K-means results
```{r echo=TRUE}

```


</br>

### Session Information 

```{r Session Info, echo=FALSE}
sessionInfo()
```